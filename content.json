{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-06-04T04:25:14.000Z","updated":"2018-06-04T04:35:31.179Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"123layout: categories comments: false ---"},{"title":"tags","date":"2018-06-04T04:23:44.000Z","updated":"2018-06-04T04:35:08.483Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"123layout: tags comments: false ---"}],"posts":[{"title":"","slug":"Hibernate5总结","date":"2018-06-07T02:55:04.157Z","updated":"2018-06-25T08:06:41.056Z","comments":true,"path":"2018/06/07/Hibernate5总结/","link":"","permalink":"http://yoursite.com/2018/06/07/Hibernate5总结/","excerpt":"","text":"Hibernate5框架的总结 [TOC] Hibernate的概述1.什么是Hibernate?Hibernate是一个持久层的ORM框架,对JDBC做了封装. ###2.什么是ORM? ORM:object relation mapping—对象关联映射 3.为什么使用Hibernate框架1.对JDBC做了轻量级封装 2.优秀的ORM实现,简化了DAO的编码 3.性能好,支持很多关系型数据库 4.可扩展性强 具体见–Hibernate百度百科 Hibernate的入门1.创建项目,导入相应的jar包 hibernate核心包 日志记录包 数据库驱动包 2.创建相应的数据库和表3.编写POJO类 普通的javaBean类 4.编写POJO对应的映射配置文件–xxx.hbm.xml 映射id主键 映射其它属性 映射级联属性(如多对一,一对多,多对多,一对一) Hibernate的主键生成策略 native(自动按照方言来实现自增长) identity(mysql主键生成方式) sequence(oracle主键生成方式) assigned(自然主键–如身份证编号等等) uuid(字符串类型的id) 5.编写hibernate核心配置文件 [ ] 配置数据源属性(例如url,driverclass等等) [ ] 配置hibernate相关属性 格式化sql 控制打印sql语句 Hibernate中设置与当前线程绑定的session的使用 session对象的生命周期和本地线程绑定 自动关闭,事务的开启关闭也随本地线程开启而开启,关闭而关闭 设置连接池 设置事务隔离级别 read-uncommitted—2 不能解决任何问题,安全性最低,性能最高 read-committed-----4 sql-server,oracle默认级别 repeatable-read----8 mysql默认级别 serializable------16 能解决任何问题,性能最低,安全性最高 ​ 加载映射文件 ​ Hibernate相关APIConfigurationsessionFactorysession 1234567891011121314151617181920212223242526272829303132333435363738394041public class Demo1 &#123; /** * 用hibernate.cfg.xml配置核心配置文件的做法 */ @Test public void save()&#123; /*第一种 和对应的类不在同一个包下 Configuration configuration = new Configuration(); configuration.addResource(\"com/itheima/domain/Customer.hbm.xml\");*/ /*第二种 和对应的类在同一个包下 Configuration configuration = new Configuration(); configuration.addClass(Customer.class);*/ //第三种 第一步:获取核心配置文件(核心配置文件已经加载了映射文件,这是第三种(推荐的做法)) Configuration configuration = new Configuration().configure(); //获取sessionFactory 相当于JDBC的连接池 SessionFactory sessionFactory = configuration.buildSessionFactory(); //通过sessionFactory获得session 相当于JDBC的连接 Session session = sessionFactory.openSession(); Transaction transaction = null; try &#123; //开启事务 transaction = session.beginTransaction(); //操作对象 Customer customer = new Customer(); customer.setIndustry(\"互联网行业\"); customer.setLevel(\"1\"); customer.setMobile(\"18888888888\"); customer.setName(\"马腾\"); customer.setPhone(\"021-88888\"); customer.setSource(\"网上搜查\"); Serializable id = session.save(customer); System.out.println(id); //事务提交 transaction.commit(); &#125; catch (Exception e) &#123; //事务回滚 transaction.rollback(); &#125; &#125; session的crud: save delete update get(立即加载) load(延迟加载) ​ Hibernate的持久化类持久化类的定义及编写规则持久化类的定义:定义:一个javaBean类对应着一个映射文件,与数据库表建立联系 持久化类的编写规则:1.不能用final修饰,不然无法通过代理类实现延迟加载 2.提供私有属性,提供公益的get.set方法 3.属性尽量用包装类型 4.提供特定标识OID,与数据库表的主键对应 5.提供无参构造,用来为hibernate提供反射 持久化类的三种状态及相互转化 瞬时态 持久态 脱管态 OID 无 有 有 session管理 无 有 无 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package com.itheima.hibernate.demo;import com.itheima.hibernate.domain.Customer;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.itheima.hibernate.utils.HibernateUtils;public class HibernateDemo1 &#123; /** * 测试hibernate实体类对象的状态 */ @Test public void test01()&#123; Session session = HibernateUtils.OpenSession(); //开启事务 Transaction transaction = session.beginTransaction(); //创建实体类 Customer customer = new Customer();//实体类对象的瞬时态,没有id,没有加入session管理 customer.setId(1L);//设置id,变为脱管态,有id,没有加入session管理 customer.setName(\"李世民3\"); customer.setPhone(\"188888888\"); customer.setIndustry(\"唐朝\"); customer.setLevel(\"一等客户\"); customer.setMobile(\"66666666\"); customer.setSource(\"书\"); session.save(customer);//此时customer变为持久态,可以自动更新 //事务提交 transaction.commit(); session.close();//此时customer变成了脱管态 &#125; /** * 测试hibernate实体类对象的状态之间相互的转换 */ @Test public void test02()&#123; Session session = HibernateUtils.OpenSession(); //开启事务 Transaction transaction = session.beginTransaction(); //创建实体类 Customer customer = new Customer();//实体类对象的瞬时态,没有id,没有加入session管理 customer.setId(5L);//当设置的id不存在的时候,此时customer为瞬时态:没有OID,没有加入session //customer.setId(1L);//当设置的id存在的时候,此时customer为脱管态:有OID,没有加入session customer.setName(\"张飞\"); customer.setIndustry(\"三国\"); session.save(customer);//调用save或者update此时customer变为持久态,可以自动更新 //saveOrUpdate方法:当customer为瞬时态则调用save方法,当customer为脱管态则调用update方法 //session.delete(customer);//customer直接从持久态变为瞬时态 //事务提交 transaction.commit(); session.close();//此时customer变成了脱管态 &#125; /** * 测试clear方法:清除session所有对象,将customer持久态转化为脱管态 */ @Test public void clear()&#123; Session session = HibernateUtils.OpenSession(); Transaction transaction = session.beginTransaction(); Customer customer = session.get(Customer.class, 2L);//持久态 session.clear();//清除session的所有对象 System.out.println(customer);//customer变为脱管态 transaction.commit(); session.close(); &#125; /** * 测试evict方法:清除session某个对象,将customer持久态转化为脱管态 */ @Test public void evict()&#123; Session session = HibernateUtils.OpenSession(); Transaction transaction = session.beginTransaction(); Customer customer = session.get(Customer.class, 2L);//持久态 session.evict(customer);//清除session的customer System.out.println(customer);//customer变为脱管态 transaction.commit(); session.close(); &#125; /** * 测试:当对象为持久态的时候,可以自动更新 */ @Test public void auto_Update()&#123; Session session = HibernateUtils.OpenSession(); Transaction transaction = session.beginTransaction(); Customer customer = session.get(Customer.class, 2L);//持久态 customer.setName(\"关羽\");//customer已经是持久态,不需要调用session的update,就能更改表,自动更新 transaction.commit(); session.close(); &#125; /** * 测试主键生成策略---increment hibernate内部的自动增长机制,会先查询表中的MAX(id),然后插入数据 * 缺点:线程不安全,多线程存储数据的时候会出现问题 * 应用debug模式,两个线程同时添加数据,第一次可以添加成功,第二次就因为id一样就报错:Duplicate entry key 重复的主键error */ @Test public void increment()&#123; Session session = HibernateUtils.OpenSession(); //开启事务 Transaction transaction = session.beginTransaction(); //创建实体类 Customer customer = new Customer(); customer.setName(\"陆小凤\"); session.save(customer);//当保存数据的时候,会先查询数据库中Max(id),然后再加一,然后再添加进去 transaction.commit(); session.close(); &#125; /** * 测试:测试主键生成策略 uuid,随机生成uuid格式的主键 * 要求:持久化类的id主键为string类型 */ @Test public void UUID()&#123; Session session = HibernateUtils.OpenSession(); //开启事务 Transaction transaction = session.beginTransaction(); //创建实体类 Customer customer = new Customer(); customer.setName(\"诸葛亮\");//得到4028a68163ac13970163ac13991d0000的uuid形式的id session.save(customer); transaction.commit(); session.close(); &#125; /** * 测试:测试主键生成策略 assigned,即自然主键,自己手动设置个人信息唯一的id,如:身份证,如登录id+时间戳 * 要求:持久化类的id主键为string类型 */ @Test public void assigned()&#123; Session session = HibernateUtils.OpenSession(); //开启事务 Transaction transaction = session.beginTransaction(); //创建实体类 Customer customer = new Customer(); customer.setId(2018052921301515L); customer.setName(\"赵云\");//得到4028a68163ac13970163ac13991d0000的uuid形式的id session.save(customer); transaction.commit(); session.close(); &#125;&#125; Hibernate的缓存和快照Hibernate的缓存机制Hibernate的一级缓存第一次通过id向数据库查询,发送sql语句,然后将这个数据加载进缓存,之后的每一次访问这个数据就可以直接访问缓存来获得这个数据,不用发送sql语句查询数据库了(session未关闭的情况下). 生命周期:是session的生命周期,session一关闭,一级缓存就消失 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.itheima.hibernate.demo;import com.itheima.hibernate.domain.Customer;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.itheima.hibernate.utils.HibernateUtils;public class HibernateDemo2 &#123; /** * 测试一级缓存的存在: * 一级缓存:当第一次通过id向数据库查询数据时,hibernate会将id为key,对象为value存入session的缓存中 * 第二次查询这个id数据的时候,就直接向缓存中拿这个key相应的对象即可(hibernate性能优化的一个方式) * 一级缓存的生命周期:当session关闭的时候,一级缓存就结束了 */ @Test public void firstCache()&#123; Session session = HibernateUtils.OpenSession(); Transaction transaction = session.beginTransaction(); Customer customer = session.get(Customer.class, 2L);//向数据库发送了sql查询语句 System.out.println(customer); Customer customer2 = session.get(Customer.class, 2L);//没有发送sql语句,直接从一级缓存中获取 System.out.println(customer2); System.out.println(customer == customer2);//打印出来为true,说明拿出来的对象是一样的 transaction.commit(); session.close(); &#125; /** * 测试一级缓存的快照区:快照，是数据在内存中的副本，是数据库中数据在内存中的映射。 * 当session加载了customer对象后,会为customer创建一个快照副本(快照区),当事务提交后(会刷出缓存) * 会比对快照区和一级缓存区,然后来比对哪些属性变化,然后向数据库发送update更新数据 */ @Test public void snapShot()&#123; Session session = HibernateUtils.OpenSession(); Transaction transaction = session.beginTransaction(); Customer customer = session.get(Customer.class, 2L); customer.setName(\"刘备2\"); transaction.commit(); session.close(); &#125; /** * * session的生命周期和本地线程绑定: * 在核心配置文件中配置:&lt;!-- 设置与当前线程绑定的session --&gt; &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt; 这样一个线程结束,session会自动关闭,不用调用session.close手动关闭 */ @Test public void testThreadSession()&#123; Session session = HibernateUtils.getCurrentSession();//另一个方法调用getCurrentSession,得到的是同一个session Transaction transaction = session.beginTransaction(); Customer customer = session.get(Customer.class, 2L); customer.setName(\"刘备3\"); transaction.commit(); &#125;&#125; Hibernate的二级缓存sessionFactory Hibernate的快照快照的定义定义:快照，是数据在内存中的副本，是数据库中数据在内存中的映射 快照的原理原理:当session缓存加载了一个对象的时候,会为这个对象的值类型复制存入一片快照区域,操作对象改变的时候只会改变session的缓存,不会改变快照区,当事务提交(刷出缓存)的时候,快照会和缓存去进行对比,如果不一样就会想数据库发送update语句,更新数据库变为缓存区一样的数据. Hibernate的三种查询方式QBC查询SQL查询HQL查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.itheima.hibernate.demo;import java.util.List;import com.itheima.hibernate.domain.Customer;import org.hibernate.Criteria;import org.hibernate.Query;import org.hibernate.SQLQuery;import org.hibernate.Session;import org.hibernate.Transaction;import org.hibernate.criterion.Restrictions;import org.junit.Test;import com.itheima.hibernate.utils.HibernateUtils;public class HibernateDemo3 &#123; /** * 测试HQL查询 */ @Test public void HQL()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); /*//查询所有数据----HQL查询的都是对象,不是数据库的表,是通过查询对象反射到操作数据库表 Query query = session.createQuery(\"from Customer\"); //返回装有数据的list List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125;*/ /* //条件查询 Query query2 = session.createQuery(\"from Customer where name like ? and level=?\"); //设置HQL的参数 query2.setParameter(0, \"%刘%\"); query2.setParameter(1, \"一等客户\"); List&lt;Customer&gt; list2 = query2.list(); for (Customer customer : list2) &#123; System.out.println(customer); &#125;*/ //分页查询----直接setFirstResult(角标)和setMaxResults(一页展示的数量) Query query = session.createQuery(\"from Customer\"); query.setFirstResult(0); query.setMaxResults(2); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; &#125; /** * 测试QBC查询:完全面对对象,不用写sql语句 */ @Test public void QBC()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); /*//查询所有数据 Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125;*/ //条件查询 /*Criteria criteria = session.createCriteria(Customer.class); //加入限制---即加入条件 criteria.add(Restrictions.like(\"name\", \"刘\")); criteria.add(Restrictions.eq(\"level\", \"一等客户\")); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125;*/ //分页查询 Criteria criteria = session.createCriteria(Customer.class); criteria.setFirstResult(0); criteria.setMaxResults(2); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; /** * 测试SQL查询:写sql语句查询数据库 */ @Test public void SQL()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); //查询所有数据 SQLQuery sqlQuery = session.createSQLQuery(\"select * from cst_customer\"); List&lt;Object[]&gt; list = sqlQuery.list();//返回的不是customer对象,而是object数组(数据库字段和值的数组) for (Object[] objects : list) &#123; System.out.println(objects[1]); &#125; SQLQuery sqlQuery2 = session.createSQLQuery(\"select * from cst_customer\"); sqlQuery2.addEntity(Customer.class);//可以通过这个方法,将数据封装在customer,然后遍历打印出来 List&lt;Customer&gt; list2 = sqlQuery2.list(); for (Customer customer : list2) &#123; System.out.println(customer); &#125; &#125;&#125; Hibernate的映射关系Hibernate中的一对多映射(如一个客户有多个联系人) 准备工作:创建表,创建持久化类,配置映射文件 级联保存 保存客户,级联保存联系人(常用):在客户相对应的映射文件中的set标签加入属性cascade=”save-update” 保存联系人,级联保存客户:在联系人相对应的映射文件中的Many-to-one标签加入属性cascade=”save-update” 级联删除 删除客户,级联保存联系人(常用):在客户相对应的映射文件中的set标签加入属性cascade=”delete” 删除联系人,级联保存客户:在联系人相对应的映射文件中的Many-to-one标签加入属性cascade=”delete” 放弃外键维护权例子:改变联系人的客户 起源:建立双向关系会出现多余的update语句,但是为了能够更好的操作客户和联系人,需要建立双向关系 解决办法:一般由一的一方放弃外键维护权,这样既不会产生多余的uodate语句,也能建立双向关系 Hibernate的多对多映射类似一对多的情形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.itheima.hibernate.demo;import com.itheima.hibernate.domain.Customer;import com.itheima.hibernate.domain.LinkMan;import com.itheima.hibernate.utils.HibernateUtils;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.jupiter.api.Test;/** * * @author coldwind */public class HibernateOneToManyTest &#123; /** * 测试级联和导航的关系 */ @Test public void relativeObject()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name(\"张艺谋\"); LinkMan linkMan1 = new LinkMan(); linkMan1.setLkm_name(\"范冰冰\"); LinkMan linkMan2 = new LinkMan(); linkMan2.setLkm_name(\"李晨\"); LinkMan linkMan3 = new LinkMan(); linkMan3.setLkm_name(\"李冰冰\"); linkMan1.setCustomer(customer); customer.getLinkMans().add(linkMan2); customer.getLinkMans().add(linkMan3); //发出insert语句的条数 :4条 // session.save(linkMan1); //发出insert语句的条数 :3条 session.save(customer); //发出insert语句的条数:1条 // session.save(linkMan2); transaction.commit(); &#125; /** * 测试:改变某个联系人的客户的时候,建立双向关系,会产生多余的sql语句,产生两条update语句 * 但是开发中一般要建立双向关系:因为一个方法当以客户为参数的时候可以操作它的联系人 * 一个方法以联系人为参数的时候可以操作它的客户 * 为了既建立双向关系,又为了性能考虑不发送多余的update语句,一般都让一的那一方放弃主动权 * 让一的一方放弃维护外键的关系,需要在一的一方即客户的一方映射文件中加入inverse=true,即可以被反转 * 即主动放弃维护外键的权限 */ @Test public void inverseTest()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Customer customer = session.get(Customer.class, 4L); LinkMan linkMan = session.get(LinkMan.class, 9L); linkMan.setCustomer(customer); //配置客户的映射文件之后,这条代码其实是失效的,这样即使创建双方关系,也只发送一条update语句 customer.getLinkMans().add(linkMan); transaction.commit(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184package com.itheima.hibernate.demo;import com.itheima.hibernate.domain.Role;import com.itheima.hibernate.domain.User;import com.itheima.hibernate.utils.HibernateUtils;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.jupiter.api.Test;/** * Hibernate中多对多的关系映射 * @author coldwind */public class HibernateManyToManyTest &#123; /** * 测试多对多关系映射的级联保存:不能创建双向关系,中间表的联合主键会产生重复 * Duplicate:重复的意思 * Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException: Duplicate entry '1-2' for key 'PRIMARY' at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) */ @Test public void manyToManyTest()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); User user1 = new User(); user1.setUserName(\"张三丰3\"); User user2 = new User(); user2.setUserName(\"长孙无忌3\"); Role role1 = new Role(); role1.setRoleName(\"前台小姐姐3\"); Role role2 = new Role(); role2.setRoleName(\"前台小哥哥3\"); Role role3 = new Role(); role3.setRoleName(\"前台大叔叔3\"); //角色和用户创立关系 role2.getUsers().add(user1); role2.getUsers().add(user2); role3.getUsers().add(user1); //用户和角色创建关系 user1.getRoles().add(role2); user1.getRoles().add(role3); user2.getRoles().add(role2); //保存角色和用户 session.save(user1); session.save(user2); /*session.save(role1); session.save(role2); session.save(role3);*/ //提交事务 transaction.commit(); &#125; /** * 保存角色,级联保存用户 */ @Test public void saveRole()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); User user1 = new User(); user1.setUserName(\"张三丰2\"); User user2 = new User(); user2.setUserName(\"长孙无忌2\"); Role role1 = new Role(); role1.setRoleName(\"前台小姐姐2\"); Role role2 = new Role(); role2.setRoleName(\"前台小哥哥2\"); Role role3 = new Role(); role3.setRoleName(\"前台大叔叔2\"); //角色和用户创立关系 role2.getUsers().add(user1); role2.getUsers().add(user2); role3.getUsers().add(user1); //用户和角色创建关系 user1.getRoles().add(role2); user1.getRoles().add(role3); user2.getRoles().add(role2); session.save(role1); session.save(role2); session.save(role3); transaction.commit(); &#125; /** * 删除角色,级联删除用户,必须持久态的对象才能删除 */ @Test public void deleteRole()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Role role1 = session.get(Role.class, 16L); Role role2 = session.get(Role.class, 17L); Role role3 = session.get(Role.class, 18L); session.delete(role1); session.delete(role2); session.delete(role3); transaction.commit(); &#125; /** * 删除用户,级联删除角色,必须持久态的对象才能删除 */ @Test public void deleteUser()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); User user1 = session.get(User.class, 9L); User user2 = session.get(User.class, 10L); session.delete(user1); session.delete(user2); transaction.commit(); &#125; /** * 给用户添加角色 */ @Test public void addRole()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); User user1 = session.get(User.class, 2L); Role role = session.get(Role.class, 1L); role.getUsers().add(user1); transaction.commit(); &#125; /** * 给用户删除角色 */ @Test public void deleteRoleFromUser()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); User user1 = session.get(User.class, 2L); Role role = session.get(Role.class, 1L); //注意有没有哪一方放弃外键维护权 role.getUsers().remove(user1); transaction.commit(); &#125; /** * 给用户选择角色 */ @Test public void selectRole()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); User user1 = session.get(User.class, 2L); Role role1 = session.get(Role.class, 1L); Role role2 = session.get(Role.class, 2L); //注意有没有哪一方放弃外键维护权 role2.getUsers().remove(user1); role1.getUsers().add(user1); transaction.commit(); &#125;&#125; Hibernate的一对一映射 Hibernate的5种检索方式1.通过OID检索:get、load 2.通过对象导航检索 3.HQL检索 ​ 条件查询检索 排序检索 分页检索 多表查询检索 基本检索 4.QBC检索 ​ 基本检索 分页检索 多表查询检索 条件查询检索 排序检索 离线查询检索 5.SQL检索 Hibernate的抓取策略123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.itheima.hibernate.demo;import com.itheima.hibernate.domain.Customer;import com.itheima.hibernate.domain.LinkMan;import com.itheima.hibernate.utils.HibernateUtils;import org.hibernate.Criteria;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.jupiter.api.Test;import java.util.List;/** * hibernate的抓取策略: * @author coldwind */public class HibernateCatchTest &#123; /** * 测试:抓取策略 * 默认是懒加载 */ @Test public void catchTest()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); //发送select语句,查询客户 Customer customer = session.get(Customer.class, 2L); //发送select语句,查询联系人表 System.out.println(customer.getLinkMans()); transaction.commit(); &#125; /** *fetch ：控制查询语句的格式。 select ：默认值，发送一条select语句查询关联对象（立即和延迟通过lazy属性决定） join ：发送一条迫切左外连接查询关联对象（lazy属性会忽略） subselect ：发送一条子查询查询其关联对象（立即和延迟通过lazy属性决定） lazy ：查询是否延迟的。 true ：默认值，延迟加载。 false ：不支持延迟加载，即立即加载。 extra ：极其懒惰 将customer映射文件的set的fetch属性改为join */ @Test public void catchTest02()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); //join：发送一条迫切左外连接查询关联对象（lazy属性会忽略） Customer customer = session.get(Customer.class, 3L); System.out.println(customer.getLinkMans()); transaction.commit(); &#125; /** * 将customer映射文件的set的fetch属性改为subselect(发送联合查询语句)(是否立即和lazy的配置有关) */ @Test public void catchTest03()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); //subselect(发送子查询(嵌套查询)语句) Customer customer = session.get(Customer.class, 4L); System.out.println(customer.getLinkMans()); transaction.commit(); &#125; /** * 查询客户批量抓取联系人 */ @Test public void catchTest04()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer.getCust_name()); for (LinkMan linkMan : customer.getLinkMans()) &#123; System.out.println(linkMan.getLkm_name()); &#125; &#125; transaction.commit(); &#125; @Test public void catchTest05()&#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); // 查询所有客户 List&lt;LinkMan&gt; list = session.createQuery(\"from LinkMan\").list(); for (LinkMan linkMan : list) &#123; System.out.println(\"联系人的名称:\"+linkMan.getLkm_name()); System.out.println(\"客户的名称:\"+linkMan.getCustomer().getCust_name()); &#125; transaction.commit(); &#125;&#125;","categories":[],"tags":[]},{"title":"PageName","slug":"PageName","date":"2018-06-04T04:22:11.000Z","updated":"2018-06-04T04:22:11.429Z","comments":true,"path":"2018/06/04/PageName/","link":"","permalink":"http://yoursite.com/2018/06/04/PageName/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-05-10T14:30:07.048Z","updated":"2018-05-23T10:06:01.157Z","comments":true,"path":"2018/05/10/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" 哈哈 我的Hexo博客....要坚持 More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}